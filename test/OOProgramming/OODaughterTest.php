<?php
/**
 * Generated by PHPUnit_SkeletonGenerator on 2015-05-05 at 10:12:15.
 * @group OOProgramming
 * @group OODaughterTest
 */
class OODaughterTest extends PHPUnit_Framework_TestCase
{
    public function testClassAlias()
    {
        class_alias('\App\OOProgramming\OODaughter', 'Son');
        $_daughter = new \App\OOProgramming\OODaughter();
        $_son = new Son();
        $_anotherSon = new Son();

        /* tests */
        $_daughter->setName('Davi'); // atribui valor à propriedade da classe
        $this->assertEquals('Davi', $_daughter->getName()); // verifica se valor da propriedade é o esperado
        $this->assertNotEquals('Davi', $_son->getName(), 'A instancia _son não recebe o valor atribuído à propriedade da instância _daughter');
        /* verifica se a instancia do alias _son, compartilha, por referência as propriedades de daughter */
        $_son->setName('Lilian'); // atribui valor à propriedade da classe
        $this->assertEquals('Lilian', $_son->getName()); // verifica valor atribuído
        $this->assertNotEquals('Lilian', $_anotherSon->getName()); // verifica se outra instancia do alias, compartilha, por referência as propriedades da classe
        /* verifica nomes das classes dos alias */
        $this->assertEquals('App\OOProgramming\OODaughter', get_class($_son)); // verifica se nome da classe é o nome original da classe, não o alias
        $this->assertNotEquals('Son', get_class($_anotherSon)); // verifica se nome da classe da instancia do alias não é Son
        
        unset($_daughter);
        unset($_son);
        unset($_anotherSon); // 'destroi' instancias
    }

    public function testDuplicatingInstance()
    {
        /* instancia classe */
        $_daughter = new \App\OOProgramming\OODaughter();
        $_sister = $_daughter; // cria nova instancia à partir de $_daughter
        $_daughter->setName('Yeshua'); // atribui valor à propriedade, através da instância $_daughter
        /* verifica se instancia $_sister, teve propriedade name alterada, depois de alterar-se a mesma, na instância $_daughter */
        $this->assertEquals('Yeshua', $_sister->getName()); // a instancia não foi clonada é sim referenciada
    }

    public function testDestructingObject()
    {
        $_daughter = new \App\OOProgramming\OODaughter();
        $_sister = $_daughter; // cria nova instancia por referência
        $_daughter->setName('Luke'); // atribui valor à propriedade
        
        unset($_daughter); // 'destroi' instância, mas não o objeto
        $this->assertEquals('Luke', $_sister->getName()); // verifica-se que, de fato, objeto não foi destruído

        $_brother = $_sister->getInstance(); // cria nova instância, desta vez, totalmente nova, não compartilha o mesmo endereço de memória de $_sister
        $this->assertNull($_brother->getName()); // verifica-se que instância criada não possui a propriedade setada, pois consiste-se de uma nova instância

        unset($_sister);
        unset($_brother); // 'destroi' instancias de objetos
    }

    public function testReturnArgsPassed()
    {
        // instancia objeto
        $_daughter = new \App\OOProgramming\OODaughter();
        // passa argumentos à função, para captura de array dos mesmos
        $args = $_daughter->returnArgsPassed('first', 'second', 'third');
        $this->assertCount(3, $args); // verifica se array de retorno contém 3 elementos
        $this->assertContains('first', $args); // verifica se valor existe em qualquer dos elementos
    }

    public function testReturnObjVars()
    {
        // instancia objeto
        $_daughter = new \App\OOProgramming\OODaughter();
        $_daughter->setName('The King David');
        $vars = $_daughter->returnObjVars();
        /* valor retornado é resultado de chamada à função
         * get_object_vars(), como pode-se perceber, conseguimos acessar 
         * mesmo sendo essa protected.
         */
        $this->assertContains('The King David', $vars);
    }
}
