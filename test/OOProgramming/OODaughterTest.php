<?php

/**
 * Generated by PHPUnit_SkeletonGenerator on 2015-05-05 at 10:12:15.
 */

/**
 * @group OOProgramming
 * @group OODaughterTest
 * @author Thiago Mallon <thiagomallon@gmail.com>
 */
class OODaughterTest extends PHPUnit_Framework_TestCase
{

    /**
     * Método testa funções class_alias() e get_class() do PHP.
     *
     * class_alias() - Cria um alias da classe, ao qual novas instâncias podem ser geradas. As
     * instâncias geradas através de um alias se fazem novas instâncias e não compartilham por
     * referência os métodos e propriedades.
     *
     * get_class() - Recebe uma instância e retorna o nome da classe da mesma.
     *
     * @return void
     */
    public function testClassAlias()
    {
        class_alias('\App\OOProgramming\OODaughter', 'Son');
        $_daughter = new \App\OOProgramming\OODaughter();
        $_son = new Son();
        $_anotherSon = new Son();

        /* tests */
        $_daughter->setName('Davi'); // atribui valor à propriedade da classe
        $this->assertEquals('Davi', $_daughter->getName()); // verifica se valor da propriedade é o esperado
        $this->assertNotEquals('Davi', $_son->getName(), 'A instancia _son não recebe o valor atribuído à propriedade da instância _daughter');
        /* verifica se a instancia do alias _son, compartilha, por referência as propriedades de daughter */
        $_son->setName('Lilian'); // atribui valor à propriedade da classe
        $this->assertEquals('Lilian', $_son->getName()); // verifica valor atribuído
        $this->assertNotEquals('Lilian', $_anotherSon->getName()); // verifica se outra instancia do alias, compartilha, por referência as propriedades da classe
        /* verifica nomes das classes dos alias */
        $this->assertEquals('App\OOProgramming\OODaughter', get_class($_son)); // verifica se nome da classe é o nome original da classe, não o alias
        $this->assertNotEquals('Son', get_class($_anotherSon)); // verifica se nome da classe da instancia do alias não é Son
        
        unset($_daughter);
        unset($_son);
        unset($_anotherSon); // 'destroi' instancias
    }

    /**
     * Método testa duplicação de instâncias, abordagem que cria instâncias por referência.
     * @return void
     */
    public function testDuplicatingInstance()
    {
        /* instancia classe */
        $_daughter = new \App\OOProgramming\OODaughter();
        $_sister = $_daughter; // cria nova instancia à partir de $_daughter
        $_daughter->setName('Yeshua'); // atribui valor à propriedade, através da instância $_daughter
        /* verifica se instancia $_sister, teve propriedade name alterada, depois de alterar-se a mesma, na instância $_daughter */
        $this->assertEquals('Yeshua', $_sister->getName()); // a instancia não foi clonada é sim referenciada
    }

    /**
     * Método testa 'destruição' de instância. Verifica-se que por mais que seja aplicada a função
     * unset() à instância, o objeto permanece até que qualquer outro compartilhamento por referência,
     * do mesmo, esteja em uso.
     * @return void
     */
    public function testDestructingObject()
    {
        $_daughter = new \App\OOProgramming\OODaughter();
        $_sister = $_daughter; // cria nova instancia por referência
        $_daughter->setName('Luke'); // atribui valor à propriedade
        
        unset($_daughter); // 'destroi' instância, mas não o objeto
        $this->assertEquals('Luke', $_sister->getName()); // verifica-se que, de fato, objeto não foi destruído

        $_brother = $_sister->getInstance(); // cria nova instância, desta vez, totalmente nova, não compartilha o mesmo endereço de memória de $_sister
        $this->assertNotNull($_brother->getName()); // verifica-se que instância criada não possui a propriedade setada, pois consiste-se de uma nova instância
        $this->assertEquals('MotherClass!DaughterClass!', $_brother->getName());

        unset($_sister);
        unset($_brother); // 'destroi' instancias de objetos
    }

    /**
     * Método testa retorno da função func_get_args(), que é o retorno do método returnArgsPassed(), do
     * objeto. Confirma-se que o PHP não espera um número máximo de argumentos passados à um método,
     * somente um número mínimo, ou seja, quando o método espera um parâmetro em sua assinatura, esse
     * um parâmetro (pelo menos) deve ser passado.
     * @return void
     */
    public function testReturnArgsPassed()
    {
        // instância objeto
        $_daughter = new \App\OOProgramming\OODaughter();
        // passa argumentos à função, para captura de array dos mesmos
        $args = $_daughter->returnArgsPassed('first', 'second', 'third');
        $this->assertCount(3, $args); // verifica se array de retorno contém 3 elementos
        $this->assertContains('first', $args); // verifica se valor existe em qualquer dos elementos
    }

    /**
     * Método testa retorno da função get_object_vars() do PHP, que é o retorno do método returnObjVars()
     * do objeto. A função é capaz de retornar todas as propriedades do objeto, bem como seus respectivos
     * valores, independentemente do encapsulamento que lhe(s) é(seja) atribuído.
     * @return void
     */
    public function testReturnObjVars()
    {
        // instancia objeto
        $_daughter = new \App\OOProgramming\OODaughter();
        $_daughter->setName('The King David');
        $vars = $_daughter->returnObjVars();
        /* valor retornado é resultado de chamada à função
         * get_object_vars(), como pode-se perceber, conseguimos acessar 
         * mesmo sendo essa protected.
         */
        $this->assertContains('The King David', $vars);
    }
}
