<?php

/**
 * Generated by PHPUnit_SkeletonGenerator on 2015-05-05 at 13:17:22.
 */

/**
 * @subpackage Test\OOProgramming
 */
namespace Test\OOProgramming;

/**
 * Classe de testes para objeto MagicMethods
 * @author Thiago Mallon <thiagomallon@gmail.com>
 * @group OOProgramming
 * @group OOProgramming/MagicMethodsTest
 */
class MagicMethodsTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var MagicMethods $_itsNoMagic Armazenará instância de MagicMethods
     */
    protected $_itsNotMagic;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    public function setUp()
    {
        /* atribui instância da classe OOMohter à propriedade $_itsNotMagic */
        $this->_itsNotMagic = new \App\OOProgramming\MagicMethods();
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    public function tearDown()
    {
        /* 'destroi' instancia da classe */
        unset($this->_itsNotMagic);
    }

    /**
     * Testa-se chamada à método indefinido, através do método mágico __call(),
     * implementado no objeto da instância.
     * @return void
     * @covers App\OOProgramming\MagicMethods::__call
     */
    public function testCallMagicMethod()
    {
        /* expressão abaixo executa método mágico __call(), da classe Mother, já que o método
         * justAddedMethod(), não existe na classe Mother, mas o método __call() */
        $res = $this->_itsNotMagic->justAddedMethod(['First', 'Second', 'Third']);
        $this->assertCount(1, $res); // confirma array de dois elementos como retorno do método
        $this->assertcount(3, $res[0]); /* confirma array de três elementos, referente ao array, passado
                                         * como segundo argumento ao método justAddedMethod() */
        $this->assertContains('First', $res[0][0]); /* verifica se existe valor 'First' em algum dos elementos
                                                     * do array de argumentos, retornado */
    }

    /**
     * Testa-se atribuição de valor à propriedade inacessível, através do método mágico
     * __set(), implementado no objeto da instância.
     * @return void
     * @covers App\OOProgramming\MagicMethods::__set
     * @covers App\OOProgramming\MagicMethods::__get
     */
    public function testGetSetMagicMethod()
    {
        $this->_itsNotMagic->notDefProp = 'Setando private';
        $this->assertEquals('Setando private', $this->_itsNotMagic->notDefProp);
        /* Na linha seguinte, através do retorno da função get_object_vars, constata-se que não cria-se, de fato
         * uma nova propriedade, mas, assim como está na implementação do método __set(), atribui-se
         * a um array, que então retorna, pelo método __get() */
         // var_dump(get_object_vars($this->_itsNotMagic));
    }

    /**
     * Testa-se interceptação da função isset(), através do método mágico __isset(), declarado na classe
     * do objeto. A função é interceptada quando chama-se a função isset(), passando-se uma propriedade
     * inacessível (ou inexistente), no objeto.
     * @return void
     * @covers App\OOProgramming\MagicMethods::__isset
     */
    public function testIssetMagicMethod()
    {
        $this->markTestIncomplete('Incompleted test of __isset() magic method');
        // $this->_itsNotMagic->notDef = 'Setted!';
        // var_dump(isset($this->_itsNotMagic->notDef));
        // var_dump(isset($this->_itsNotMagic->vatapa));
    }

    /**
     * Método
     * @return void
     * @covers App\OOProgramming\MagicMethods::__sleep
     */
    public function testSleepMagicMethod()
    {
        $this->_itsNotMagic->property1 = 'Mingal de aveia';
        $this->_itsNotMagic->notDef = 'Propriedade ndef';
        $serialized = serialize($this->_itsNotMagic);
        //var_dump($serialized);
        $unserialized = unserialize($serialized);
        // print $unserialized->notDef;
        $this->assertEquals('Propriedade ndef', $unserialized->notDef);
        /* verifica-se através da expressão acima que foram preservados tanto propriedades como
        métodos declarados na classe do objeto, já a expressão acima, fez uso do método mágico
        __set(), declarado na classe MagicMethods(), pois a propriedade notDef, não existe na
        classe, mas foi declarada pelo método __set() e retornada pelo método __get()*/
    }

    /**
     * Testa-se impressão de instância como string, através do método mágico __toString(),
     * implementado no objeto da instância.
     * @return void
     * @covers App\OOProgramming\MagicMethods::__toString
     */
    public function testToStrindMagicMethod()
    {
        $_localWithoutMagic = new \App\OOProgramming\MagicMethods();
        ob_start(); // iniciliaza output buffer
        print $_localWithoutMagic; // faz-se chamada indireta ao método mágico __toString() da classe
        $toStringMsg = ob_get_clean(); // captura-se saída, limpa-se buffer de saída e retorna-se a mesma

        // verifica-se se método __toString() foi acionado e retornou a msg esperada
        $this->assertEquals('Hey, this is not a string, this is the MagicMethods class. Welcome aboard, pirate!', $toStringMsg);
    }

    /**
     * Testa-se sobrescrição do var_dump, através do método mágico __debugInfo(), implementado
     * no objeto da instância.
     */
    public function testVarDumpOverrite()
    {
        /* O teste não dará certo, pois o método mágico __debugInfo() só foi adicionado após versão 5.6.0
         * do PHP. */
        //var_dump($this->_itsNotMagic);
    }
}
